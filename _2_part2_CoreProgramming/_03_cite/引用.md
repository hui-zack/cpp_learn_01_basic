[toc]
    [引用的概念和创建引用](#引用的概念和创建引用)
    [引用方式传递参数](#引用方式传递参数)
    [引用方式返回数据](#引用方式返回数据)
    [常量引用作为形参](#常量引用作为形参)

# 引用的概念和创建引用
.   [1-1 创建一个普通引用](./_1_createCite/CreateCite.cpp)
    [1-2 把引用当作别名来修改原变量](./_1_createCite/CreateCite.cpp)
    [1-3 创建一个常引用](./_1_createCite/CreateCite.cpp)
    [1-4 打印常引用地址发现其数组存储在堆区](./_1_createCite/CreateCite.cpp)

    注意:
        创建引用时不会在内存中开辟地址
        引用只能获取堆区和栈区的地址
            int & citeNum = 10 是错误的, 10的内存地址是全局-常量区

            const int & citeNum = 10 是可以的
                创建常引用的话, 编译器自动为在栈区申请新地址, 并复制常量数据过来

    引用的特点: 
        引用等同与原变量名, 编译后的引用和原变量名完全是一个东西, 都是同一个内存地址
        引用必须具有初始化值

    引用的本质
        变量名在内存中去执行时, 会变成一个内存地址(内存中不存储我们定义的变量名称)
        引用在内存中和原变量名的编译地址完全相同(引用在内存中执行时, 会变成和原变量名完全相同的内存地址)
        引用在使用上等同与指针常量, 但指针常量会在内存中开辟新地址, 引用不会

    引用和原变量名的相同点:
        变量名在内存中去执行时, 会变成一个内存地址(内存中不存储我们定义的变量名称)
        引用在内存中执行时, 会变成和原变量名完全相同的内存地址
        因此不涉及传参时: 引用全等于变量名

    引用和原变量名的不同点:
        变量名作为参数传递时, 会在内存中复制其存储的数据到一个新的内存地址传入
        引用作为参数传递时, 会直接将原先的地址传入
        也就是说, 引用作为形参, 函数内对形参的修改会会直接修改实参, 普通形参由于会复制数据到新地址, 因此不会修改实量

# 引用方式传递参数
.   [2 参数的引用传递](./_2_citeAsFuncFormalParam/CiteAsFuncParam.cpp)
    
    引用参数参数: 参数的引用传递, 实参直接传入编译地址, 函数内修改参数, 会修改实参数据
    指针传递参数: 实参直接传入编译地址, 函数内修改参数, 会修改实参数据
    值传递参数: 实参的编译地址会复制数据到一个新的内存地址, 并将新的内存地址传入

# 引用方式返回数据
.   [3 引用方式返回数据]
        [3-1 引用方式返回数据](./_3_citeAsReturnValue/_1_citeAsReturnValue.cpp)
        [3-2 使用引用接收引用型返回值](./_3_citeAsReturnValue/_1_citeAsReturnValue.cpp)
        [3-3 使用普通方式接收引用型返回值](./_3_citeAsReturnValue/_1_citeAsReturnValue.cpp)
        [3-4 引用方式作为左值](./_3_citeAsReturnValue/_1_citeAsReturnValue.cpp)

    引用方式返回数据, 是直接返回了一个可操作地址, 因此具有如下特点:
        只能返回全局变量, 不要返回局部变量, 局部变量存放在栈区, 函数调用完成后被释放
        可以作为左值使用:
            method() = 1000;
    由于引用方式只能返回全局遍历, 返回值的接收方式有如下两种: 
        使用引用来接收, 会对返回的编译地址直接修改数据(修改接收的引用数据, 会修改全局变量)
        使用普通方式来接收, 会创建的编译地址, 并复制返回编译地址的数据(因此修改接收的引用数据, 不会修改该全局变量)

    值返回函数在特殊场景下会使用引用:
        当在函数内部定义的自定义对象作为该函数的值返回类型时:
            古老的编译器(如微软的编译器)会通过该对象的拷贝构造创建新对象返回, 性能低
            新版本的编译器会直接返回引用:
                外部没有使用该对象将直接将该对象释放内存
                外部有使用则会扩展该对象的作用域, 提高了性能
# 常量引用作为形参
.   [4-1 引用方式作为形参, 避免原值误操作, 且不会开辟新内存, 减少内存消耗](./_4_constCite/_1_constCiteAsFuncFormalParam.cpp)
    
    常量引用作为形参::
         避免原值误操作, 且不会开辟新地址, 减少内存消耗

# 右值引用
.   [5-1 通过左值(地址值)获取右值引用, 转移资源到新对象, 节省复制开销](./_5_rightCity/_1_useRightCite.cpp)
    [5-2 使用is_rvalue_reference<decltype(move(camera))>::value判断是否为右值引用](./_5_rightCity/_1_useRightCite.cpp)
    
    判断是左值引用还是右值引用的方法
         auto &integer1 = integer++;        //不报错则为左值引用
         auto &&integer1 = integer++;       //不保存则为右值引用
    
    引用类型形参对:
        常用引用类型作为形参, 既可以接收左值引用, 也可以接收右值引用
        非常量引用类型(Camera& camera)作为形参, 只能接收左值引用
        非常量右值引用(Camera&& camera)作为形参, 只能接收右值引用

    c++判断左值和右值(基本数据类型不需要用到右值引用):
        左值: 可以取地址的，有名字的，非临时的就是左值
        右值: 
            不能取地址的，没有名字的，临时的(将亡的)就是右值
            右值在进行 
    相关函数:
        std::move(T t);                             // 根据左值获取其右值引用
        is_lvalue_reference<decltyp(T t)>::value    // 判断是否为左值引用类型
        
    右值引用:
        使用了右值引用, 原对象就会变成空对象(数据被转移)
        右值引用主要用在值传递和值返回领域, 来转移将亡对象的内容, 避免了使用拷贝构造创建新对象的步骤, 提高了性能
    

    右值引用实现了移动语义和完美转发, 优化了性能

    